<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A thread local storage (TLS) key which owns its contents."><title>LocalKey in cs431_homework::test::loom::thread - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-069232aa.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="cs431_homework" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (2fd855fbf 2025-08-07)" data-channel="nightly" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../../../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../cs431_homework/index.html">cs431_<wbr>homework</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Local<wbr>Key</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#initialization-and-destruction" title="Initialization and Destruction">Initialization and Destruction</a></li><li><a href="#single-thread-synchronization" title="Single-thread Synchronization">Single-thread Synchronization</a></li><li><a href="#examples" title="Examples">Examples</a></li><li><a href="#platform-specific-behavior" title="Platform-specific behavior">Platform-specific behavior</a><ul><li><a href="#synchronization-in-thread-local-destructors" title="Synchronization in thread-local destructors">Synchronization in thread-local destructors</a></li></ul></li></ul><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.inner" title="inner">inner</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.get" title="get">get</a></li><li><a href="#method.replace" title="replace">replace</a></li><li><a href="#method.replace-1" title="replace">replace</a></li><li><a href="#method.set" title="set">set</a></li><li><a href="#method.set-1" title="set">set</a></li><li><a href="#method.take" title="take">take</a></li><li><a href="#method.take-1" title="take">take</a></li><li><a href="#method.try_with" title="try_with">try_with</a></li><li><a href="#method.update" title="update">update</a></li><li><a href="#method.with" title="with">with</a></li><li><a href="#method.with_borrow" title="with_borrow">with_borrow</a></li><li><a href="#method.with_borrow_mut" title="with_borrow_mut">with_borrow_mut</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-LocalKey%3CT%3E" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-LocalKey%3CT%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-LocalKey%3CT%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-LocalKey%3CT%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-LocalKey%3CT%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-LocalKey%3CT%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-LocalKey%3CT%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-Pointable-for-T" title="Pointable">Pointable</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-VZip%3CV%3E-for-T" title="VZip&#60;V&#62;">VZip&#60;V&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In cs431_<wbr>homework::<wbr>test::<wbr>loom::<wbr>thread</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">cs431_homework</a>::<wbr><a href="../../index.html">test</a>::<wbr><a href="../index.html">loom</a>::<wbr><a href="index.html">thread</a></div><h1>Struct <span class="struct">LocalKey</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#110">Source</a> </span></div><pre class="rust item-decl"><code>pub struct LocalKey&lt;T&gt;<div class="where">where
    T: 'static,</div>{
    inner: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.fn.html">fn</a>(<a class="enum" href="../option/enum.Option.html" title="enum cs431_homework::test::loom::option::Option">Option</a>&lt;&amp;mut <a class="enum" href="../option/enum.Option.html" title="enum cs431_homework::test::loom::option::Option">Option</a>&lt;T&gt;&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const T</a>,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A thread local storage (TLS) key which owns its contents.</p>
<p>This key uses the fastest possible implementation available to it for the
target platform. It is instantiated with the <a href="../macro.thread_local.html" title="macro cs431_homework::test::loom::thread_local"><code>thread_local!</code></a> macro and the
primary method is the <a href="struct.LocalKey.html#method.with" title="method cs431_homework::test::loom::thread::LocalKey::with"><code>with</code></a> method, though there are helpers to make
working with <a href="../cell/struct.Cell.html" title="struct cs431_homework::test::loom::cell::Cell"><code>Cell</code></a> types easier.</p>
<p>The <a href="struct.LocalKey.html#method.with" title="method cs431_homework::test::loom::thread::LocalKey::with"><code>with</code></a> method yields a reference to the contained value which cannot
outlive the current thread or escape the given closure.</p>
<h2 id="initialization-and-destruction"><a class="doc-anchor" href="#initialization-and-destruction">§</a>Initialization and Destruction</h2>
<p>Initialization is dynamically performed on the first call to a setter (e.g.
<a href="struct.LocalKey.html#method.with" title="method cs431_homework::test::loom::thread::LocalKey::with"><code>with</code></a>) within a thread, and values that implement <a href="../ops/trait.Drop.html" title="trait cs431_homework::test::loom::ops::Drop"><code>Drop</code></a> get
destructed when a thread exits. Some platform-specific caveats apply, which
are explained below.
Note that, should the destructor panics, the whole process will be <a href="../process/fn.abort.html" title="fn cs431_homework::test::loom::process::abort">aborted</a>.</p>
<p>A <code>LocalKey</code>’s initializer cannot recursively depend on itself. Using a
<code>LocalKey</code> in this way may cause panics, aborts or infinite recursion on
the first call to <code>with</code>.</p>
<h2 id="single-thread-synchronization"><a class="doc-anchor" href="#single-thread-synchronization">§</a>Single-thread Synchronization</h2>
<p>Though there is no potential race with other threads, it is still possible to
obtain multiple references to the thread-local data in different places on
the call stack. For this reason, only shared (<code>&amp;T</code>) references may be obtained.</p>
<p>To allow obtaining an exclusive mutable reference (<code>&amp;mut T</code>), typically a
<a href="../cell/struct.Cell.html" title="struct cs431_homework::test::loom::cell::Cell"><code>Cell</code></a> or <a href="../cell/struct.RefCell.html" title="struct cs431_homework::test::loom::cell::RefCell"><code>RefCell</code></a> is used (see the <a href="../cell/index.html" title="mod cs431_homework::test::loom::cell"><code>std::cell</code></a> for more information
on how exactly this works). To make this easier there are specialized
implementations for <a href="struct.LocalKey.html#impl-LocalKey%3CCell%3CT%3E%3E"><code>LocalKey&lt;Cell&lt;T&gt;&gt;</code></a> and <a href="struct.LocalKey.html#impl-LocalKey%3CRefCell%3CT%3E%3E"><code>LocalKey&lt;RefCell&lt;T&gt;&gt;</code></a>.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cell::Cell;
<span class="kw">use </span>std::thread;

<span class="comment">// explicit `const {}` block enables more efficient initialization
</span><span class="macro">thread_local!</span>(<span class="kw">static </span>FOO: Cell&lt;u32&gt; = <span class="kw">const </span>{ Cell::new(<span class="number">1</span>) });

<span class="macro">assert_eq!</span>(FOO.get(), <span class="number">1</span>);
FOO.set(<span class="number">2</span>);

<span class="comment">// each thread starts out with the initial value of 1
</span><span class="kw">let </span>t = thread::spawn(<span class="kw">move </span>|| {
    <span class="macro">assert_eq!</span>(FOO.get(), <span class="number">1</span>);
    FOO.set(<span class="number">3</span>);
});

<span class="comment">// wait for the thread to complete and bail out on panic
</span>t.join().unwrap();

<span class="comment">// we retain our original value of 2 despite the child thread
</span><span class="macro">assert_eq!</span>(FOO.get(), <span class="number">2</span>);</code></pre></div>
<h2 id="platform-specific-behavior"><a class="doc-anchor" href="#platform-specific-behavior">§</a>Platform-specific behavior</h2>
<p>Note that a “best effort” is made to ensure that destructors for types
stored in thread local storage are run, but not all platforms can guarantee
that destructors will be run for all types in thread local storage. For
example, there are a number of known caveats where destructors are not run:</p>
<ol>
<li>On Unix systems when pthread-based TLS is being used, destructors will
not be run for TLS values on the main thread when it exits. Note that the
application will exit immediately after the main thread exits as well.</li>
<li>On all platforms it’s possible for TLS to re-initialize other TLS slots
during destruction. Some platforms ensure that this cannot happen
infinitely by preventing re-initialization of any slot that has been
destroyed, but not all platforms have this guard. Those platforms that do
not guard typically have a synthetic limit after which point no more
destructors are run.</li>
<li>When the process exits on Windows systems, TLS destructors may only be
run on the thread that causes the process to exit. This is because the
other threads may be forcibly terminated.</li>
</ol>
<h3 id="synchronization-in-thread-local-destructors"><a class="doc-anchor" href="#synchronization-in-thread-local-destructors">§</a>Synchronization in thread-local destructors</h3>
<p>On Windows, synchronization operations (such as <a href="struct.JoinHandle.html#method.join" title="method cs431_homework::test::loom::thread::JoinHandle::join"><code>JoinHandle::join</code></a>) in
thread local destructors are prone to deadlocks and so should be avoided.
This is because the <a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices">loader lock</a> is held while a destructor is run. The
lock is acquired whenever a thread starts or exits or when a DLL is loaded
or unloaded. Therefore these events are blocked for as long as a thread
local destructor is running.</p>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.inner" class="structfield section-header"><a href="#structfield.inner" class="anchor field">§</a><code>inner: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.fn.html">fn</a>(<a class="enum" href="../option/enum.Option.html" title="enum cs431_homework::test::loom::option::Option">Option</a>&lt;&amp;mut <a class="enum" href="../option/enum.Option.html" title="enum cs431_homework::test::loom::option::Option">Option</a>&lt;T&gt;&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const T</a></code></span><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-LocalKey%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#240">Source</a><a href="#impl-LocalKey%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="struct" href="struct.LocalKey.html" title="struct cs431_homework::test::loom::thread::LocalKey">LocalKey</a>&lt;T&gt;<div class="where">where
    T: 'static,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#275-277">Source</a></span><h4 class="code-header">pub fn <a href="#method.with" class="fn">with</a>&lt;F, R&gt;(&amp;'static self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="../ops/trait.FnOnce.html" title="trait cs431_homework::test::loom::ops::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>) -&gt; R,</div></h4></section></summary><div class="docblock"><p>Acquires a reference to the value in this TLS key.</p>
<p>This will lazily initialize the value if this thread has not referenced
this key yet.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This function will <code>panic!()</code> if the key currently has its
destructor running, and it <strong>may</strong> panic if the destructor has
previously been run for this thread.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">thread_local!</span> {
    <span class="kw">pub static </span>STATIC: String = String::from(<span class="string">"I am"</span>);
}

<span class="macro">assert_eq!</span>(
    STATIC.with(|original_value| <span class="macro">format!</span>(<span class="string">"{original_value} initialized"</span>)),
    <span class="string">"I am initialized"</span>,
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#310-312">Source</a></span><h4 class="code-header">pub fn <a href="#method.try_with" class="fn">try_with</a>&lt;F, R&gt;(&amp;'static self, f: F) -&gt; <a class="enum" href="../result/enum.Result.html" title="enum cs431_homework::test::loom::result::Result">Result</a>&lt;R, <a class="struct" href="struct.AccessError.html" title="struct cs431_homework::test::loom::thread::AccessError">AccessError</a>&gt;<div class="where">where
    F: <a class="trait" href="../ops/trait.FnOnce.html" title="trait cs431_homework::test::loom::ops::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>) -&gt; R,</div></h4></section></summary><div class="docblock"><p>Acquires a reference to the value in this TLS key.</p>
<p>This will lazily initialize the value if this thread has not referenced
this key yet. If the key has been destroyed (which may happen if this is called
in a destructor), this function will return an <a href="struct.AccessError.html" title="struct cs431_homework::test::loom::thread::AccessError"><code>AccessError</code></a>.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>This function will still <code>panic!()</code> if the key is uninitialized and the
key’s initializer panics.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">thread_local!</span> {
    <span class="kw">pub static </span>STATIC: String = String::from(<span class="string">"I am"</span>);
}

<span class="macro">assert_eq!</span>(
    STATIC.try_with(|original_value| <span class="macro">format!</span>(<span class="string">"{original_value} initialized"</span>)),
    <span class="prelude-val">Ok</span>(String::from(<span class="string">"I am initialized"</span>)),
);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-LocalKey%3CCell%3CT%3E%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#347">Source</a><a href="#impl-LocalKey%3CCell%3CT%3E%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="struct" href="struct.LocalKey.html" title="struct cs431_homework::test::loom::thread::LocalKey">LocalKey</a>&lt;<a class="struct" href="../cell/struct.Cell.html" title="struct cs431_homework::test::loom::cell::Cell">Cell</a>&lt;T&gt;&gt;<div class="where">where
    T: 'static,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.set" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#375">Source</a></span><h4 class="code-header">pub fn <a href="#method.set" class="fn">set</a>(&amp;'static self, value: T)</h4></section></summary><div class="docblock"><p>Sets or initializes the contained value.</p>
<p>Unlike the other methods, this will <em>not</em> run the lazy initializer of
the thread local. Instead, it will be directly initialized with the
given value if it wasn’t initialized yet.</p>
<h5 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h5>
<p>Panics if the key currently has its destructor running,
and it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cell::Cell;

<span class="macro">thread_local!</span> {
    <span class="kw">static </span>X: Cell&lt;i32&gt; = <span class="macro">panic!</span>(<span class="string">"!"</span>);
}

<span class="comment">// Calling X.get() here would result in a panic.

</span>X.set(<span class="number">123</span>); <span class="comment">// But X.set() is fine, as it skips the initializer above.

</span><span class="macro">assert_eq!</span>(X.get(), <span class="number">123</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#408-410">Source</a></span><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>(&amp;'static self) -&gt; T<div class="where">where
    T: <a class="trait" href="../marker/trait.Copy.html" title="trait cs431_homework::test::loom::marker::Copy">Copy</a>,</div></h4></section></summary><div class="docblock"><p>Returns a copy of the contained value.</p>
<p>This will lazily initialize the value if this thread has not referenced
this key yet.</p>
<h5 id="panics-3"><a class="doc-anchor" href="#panics-3">§</a>Panics</h5>
<p>Panics if the key currently has its destructor running,
and it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cell::Cell;

<span class="macro">thread_local!</span> {
    <span class="kw">static </span>X: Cell&lt;i32&gt; = <span class="kw">const </span>{ Cell::new(<span class="number">1</span>) };
}

<span class="macro">assert_eq!</span>(X.get(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.take" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#438-440">Source</a></span><h4 class="code-header">pub fn <a href="#method.take" class="fn">take</a>(&amp;'static self) -&gt; T<div class="where">where
    T: <a class="trait" href="../default/trait.Default.html" title="trait cs431_homework::test::loom::default::Default">Default</a>,</div></h4></section></summary><div class="docblock"><p>Takes the contained value, leaving <code>Default::default()</code> in its place.</p>
<p>This will lazily initialize the value if this thread has not referenced
this key yet.</p>
<h5 id="panics-4"><a class="doc-anchor" href="#panics-4">§</a>Panics</h5>
<p>Panics if the key currently has its destructor running,
and it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cell::Cell;

<span class="macro">thread_local!</span> {
    <span class="kw">static </span>X: Cell&lt;<span class="prelude-ty">Option</span>&lt;i32&gt;&gt; = <span class="kw">const </span>{ Cell::new(<span class="prelude-val">Some</span>(<span class="number">1</span>)) };
}

<span class="macro">assert_eq!</span>(X.take(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(X.take(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#469">Source</a></span><h4 class="code-header">pub fn <a href="#method.replace" class="fn">replace</a>(&amp;'static self, value: T) -&gt; T</h4></section></summary><div class="docblock"><p>Replaces the contained value, returning the old value.</p>
<p>This will lazily initialize the value if this thread has not referenced
this key yet.</p>
<h5 id="panics-5"><a class="doc-anchor" href="#panics-5">§</a>Panics</h5>
<p>Panics if the key currently has its destructor running,
and it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cell::Cell;

<span class="macro">thread_local!</span> {
    <span class="kw">static </span>X: Cell&lt;i32&gt; = <span class="kw">const </span>{ Cell::new(<span class="number">1</span>) };
}

<span class="macro">assert_eq!</span>(X.replace(<span class="number">2</span>), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(X.replace(<span class="number">3</span>), <span class="number">2</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.update" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#489-491">Source</a><h4 class="code-header">pub fn <a href="#method.update" class="fn">update</a>(&amp;'static self, f: impl <a class="trait" href="../ops/trait.FnOnce.html" title="trait cs431_homework::test::loom::ops::FnOnce">FnOnce</a>(T) -&gt; T)<div class="where">where
    T: <a class="trait" href="../marker/trait.Copy.html" title="trait cs431_homework::test::loom::marker::Copy">Copy</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>local_key_cell_update</code>)</span></div></span></summary><div class="docblock"><p>Updates the contained value using a function.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(local_key_cell_update)]
</span><span class="kw">use </span>std::cell::Cell;

<span class="macro">thread_local!</span> {
    <span class="kw">static </span>X: Cell&lt;i32&gt; = <span class="kw">const </span>{ Cell::new(<span class="number">5</span>) };
}

X.update(|x| x + <span class="number">1</span>);
<span class="macro">assert_eq!</span>(X.get(), <span class="number">6</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-LocalKey%3CRefCell%3CT%3E%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#497">Source</a><a href="#impl-LocalKey%3CRefCell%3CT%3E%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="struct" href="struct.LocalKey.html" title="struct cs431_homework::test::loom::thread::LocalKey">LocalKey</a>&lt;<a class="struct" href="../cell/struct.RefCell.html" title="struct cs431_homework::test::loom::cell::RefCell">RefCell</a>&lt;T&gt;&gt;<div class="where">where
    T: 'static,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_borrow" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#522-524">Source</a></span><h4 class="code-header">pub fn <a href="#method.with_borrow" class="fn">with_borrow</a>&lt;F, R&gt;(&amp;'static self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="../ops/trait.FnOnce.html" title="trait cs431_homework::test::loom::ops::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>) -&gt; R,</div></h4></section></summary><div class="docblock"><p>Acquires a reference to the contained value.</p>
<p>This will lazily initialize the value if this thread has not referenced
this key yet.</p>
<h5 id="panics-6"><a class="doc-anchor" href="#panics-6">§</a>Panics</h5>
<p>Panics if the value is currently mutably borrowed.</p>
<p>Panics if the key currently has its destructor running,
and it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cell::RefCell;

<span class="macro">thread_local!</span> {
    <span class="kw">static </span>X: RefCell&lt;Vec&lt;i32&gt;&gt; = RefCell::new(Vec::new());
}

X.with_borrow(|v| <span class="macro">assert!</span>(v.is_empty()));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_borrow_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#555-557">Source</a></span><h4 class="code-header">pub fn <a href="#method.with_borrow_mut" class="fn">with_borrow_mut</a>&lt;F, R&gt;(&amp;'static self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="../ops/trait.FnOnce.html" title="trait cs431_homework::test::loom::ops::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>) -&gt; R,</div></h4></section></summary><div class="docblock"><p>Acquires a mutable reference to the contained value.</p>
<p>This will lazily initialize the value if this thread has not referenced
this key yet.</p>
<h5 id="panics-7"><a class="doc-anchor" href="#panics-7">§</a>Panics</h5>
<p>Panics if the value is currently borrowed.</p>
<p>Panics if the key currently has its destructor running,
and it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cell::RefCell;

<span class="macro">thread_local!</span> {
    <span class="kw">static </span>X: RefCell&lt;Vec&lt;i32&gt;&gt; = RefCell::new(Vec::new());
}

X.with_borrow_mut(|v| v.push(<span class="number">1</span>));

X.with_borrow(|v| <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>v, <span class="macro">vec!</span>[<span class="number">1</span>]));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#591">Source</a></span><h4 class="code-header">pub fn <a href="#method.set-1" class="fn">set</a>(&amp;'static self, value: T)</h4></section></summary><div class="docblock"><p>Sets or initializes the contained value.</p>
<p>Unlike the other methods, this will <em>not</em> run the lazy initializer of
the thread local. Instead, it will be directly initialized with the
given value if it wasn’t initialized yet.</p>
<h5 id="panics-8"><a class="doc-anchor" href="#panics-8">§</a>Panics</h5>
<p>Panics if the value is currently borrowed.</p>
<p>Panics if the key currently has its destructor running,
and it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cell::RefCell;

<span class="macro">thread_local!</span> {
    <span class="kw">static </span>X: RefCell&lt;Vec&lt;i32&gt;&gt; = <span class="macro">panic!</span>(<span class="string">"!"</span>);
}

<span class="comment">// Calling X.with() here would result in a panic.

</span>X.set(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// But X.set() is fine, as it skips the initializer above.

</span>X.with_borrow(|v| <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>v, <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.take-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#632-634">Source</a></span><h4 class="code-header">pub fn <a href="#method.take-1" class="fn">take</a>(&amp;'static self) -&gt; T<div class="where">where
    T: <a class="trait" href="../default/trait.Default.html" title="trait cs431_homework::test::loom::default::Default">Default</a>,</div></h4></section></summary><div class="docblock"><p>Takes the contained value, leaving <code>Default::default()</code> in its place.</p>
<p>This will lazily initialize the value if this thread has not referenced
this key yet.</p>
<h5 id="panics-9"><a class="doc-anchor" href="#panics-9">§</a>Panics</h5>
<p>Panics if the value is currently borrowed.</p>
<p>Panics if the key currently has its destructor running,
and it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cell::RefCell;

<span class="macro">thread_local!</span> {
    <span class="kw">static </span>X: RefCell&lt;Vec&lt;i32&gt;&gt; = RefCell::new(Vec::new());
}

X.with_borrow_mut(|v| v.push(<span class="number">1</span>));

<span class="kw">let </span>a = X.take();

<span class="macro">assert_eq!</span>(a, <span class="macro">vec!</span>[<span class="number">1</span>]);

X.with_borrow(|v| <span class="macro">assert!</span>(v.is_empty()));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#664">Source</a></span><h4 class="code-header">pub fn <a href="#method.replace-1" class="fn">replace</a>(&amp;'static self, value: T) -&gt; T</h4></section></summary><div class="docblock"><p>Replaces the contained value, returning the old value.</p>
<h5 id="panics-10"><a class="doc-anchor" href="#panics-10">§</a>Panics</h5>
<p>Panics if the value is currently borrowed.</p>
<p>Panics if the key currently has its destructor running,
and it <strong>may</strong> panic if the destructor has previously been run for this thread.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cell::RefCell;

<span class="macro">thread_local!</span> {
    <span class="kw">static </span>X: RefCell&lt;Vec&lt;i32&gt;&gt; = RefCell::new(Vec::new());
}

<span class="kw">let </span>prev = X.replace(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="macro">assert!</span>(prev.is_empty());

X.with_borrow(|v| <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>v, <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-LocalKey%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#129">Source</a></span><a href="#impl-Debug-for-LocalKey%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../fmt/trait.Debug.html" title="trait cs431_homework::test::loom::fmt::Debug">Debug</a> for <a class="struct" href="struct.LocalKey.html" title="struct cs431_homework::test::loom::thread::LocalKey">LocalKey</a>&lt;T&gt;<div class="where">where
    T: 'static,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/std/thread/local.rs.html#130">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="../fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../fmt/struct.Formatter.html" title="struct cs431_homework::test::loom::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="../result/enum.Result.html" title="enum cs431_homework::test::loom::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="../fmt/struct.Error.html" title="struct cs431_homework::test::loom::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="../fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-LocalKey%3CT%3E" class="impl"><a href="#impl-Freeze-for-LocalKey%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../marker/trait.Freeze.html" title="trait cs431_homework::test::loom::marker::Freeze">Freeze</a> for <a class="struct" href="struct.LocalKey.html" title="struct cs431_homework::test::loom::thread::LocalKey">LocalKey</a>&lt;T&gt;</h3></section><section id="impl-RefUnwindSafe-for-LocalKey%3CT%3E" class="impl"><a href="#impl-RefUnwindSafe-for-LocalKey%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../panic/trait.RefUnwindSafe.html" title="trait cs431_homework::test::loom::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.LocalKey.html" title="struct cs431_homework::test::loom::thread::LocalKey">LocalKey</a>&lt;T&gt;</h3></section><section id="impl-Send-for-LocalKey%3CT%3E" class="impl"><a href="#impl-Send-for-LocalKey%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../marker/trait.Send.html" title="trait cs431_homework::test::loom::marker::Send">Send</a> for <a class="struct" href="struct.LocalKey.html" title="struct cs431_homework::test::loom::thread::LocalKey">LocalKey</a>&lt;T&gt;</h3></section><section id="impl-Sync-for-LocalKey%3CT%3E" class="impl"><a href="#impl-Sync-for-LocalKey%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../marker/trait.Sync.html" title="trait cs431_homework::test::loom::marker::Sync">Sync</a> for <a class="struct" href="struct.LocalKey.html" title="struct cs431_homework::test::loom::thread::LocalKey">LocalKey</a>&lt;T&gt;</h3></section><section id="impl-Unpin-for-LocalKey%3CT%3E" class="impl"><a href="#impl-Unpin-for-LocalKey%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../marker/trait.Unpin.html" title="trait cs431_homework::test::loom::marker::Unpin">Unpin</a> for <a class="struct" href="struct.LocalKey.html" title="struct cs431_homework::test::loom::thread::LocalKey">LocalKey</a>&lt;T&gt;</h3></section><section id="impl-UnwindSafe-for-LocalKey%3CT%3E" class="impl"><a href="#impl-UnwindSafe-for-LocalKey%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../panic/trait.UnwindSafe.html" title="trait cs431_homework::test::loom::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.LocalKey.html" title="struct cs431_homework::test::loom::thread::LocalKey">LocalKey</a>&lt;T&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../any/trait.Any.html" title="trait cs431_homework::test::loom::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="../marker/trait.Sized.html" title="trait cs431_homework::test::loom::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="../any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="../any/struct.TypeId.html" title="struct cs431_homework::test::loom::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="../any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../borrow/trait.Borrow.html" title="trait cs431_homework::test::loom::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="../marker/trait.Sized.html" title="trait cs431_homework::test::loom::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="../borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="../borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../borrow/trait.BorrowMut.html" title="trait cs431_homework::test::loom::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="../marker/trait.Sized.html" title="trait cs431_homework::test::loom::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="../borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../convert/trait.From.html" title="trait cs431_homework::test::loom::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#794">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="../convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#773-775">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.Into.html" title="trait cs431_homework::test::loom::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../convert/trait.From.html" title="trait cs431_homework::test::loom::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#783">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="../convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="../convert/trait.From.html" title="trait cs431_homework::test::loom::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pointable-for-T" class="impl"><a class="src rightside" href="../../../../src/crossbeam_epoch/atomic.rs.html#194">Source</a><a href="#impl-Pointable-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.ALIGN" class="associatedconstant trait-impl"><a class="src rightside" href="../../../../src/crossbeam_epoch/atomic.rs.html#195">Source</a><a href="#associatedconstant.ALIGN" class="anchor">§</a><h4 class="code-header">const <a href="../../../../crossbeam_epoch/atomic/trait.Pointable.html#associatedconstant.ALIGN" class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>The alignment of pointer.</div></details><details class="toggle" open><summary><section id="associatedtype.Init" class="associatedtype trait-impl"><a class="src rightside" href="../../../../src/crossbeam_epoch/atomic.rs.html#197">Source</a><a href="#associatedtype.Init" class="anchor">§</a><h4 class="code-header">type <a href="../../../../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" class="associatedtype">Init</a> = T</h4></section></summary><div class='docblock'>The type for initializers.</div></details><details class="toggle method-toggle" open><summary><section id="method.init" class="method trait-impl"><a class="src rightside" href="../../../../src/crossbeam_epoch/atomic.rs.html#199">Source</a><a href="#method.init" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../../../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init" class="fn">init</a>(init: &lt;T as <a class="trait" href="../../../../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a>&gt;::<a class="associatedtype" href="../../../../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" title="type crossbeam_epoch::atomic::Pointable::Init">Init</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Initializes a with the given initializer. <a href="../../../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a class="src rightside" href="../../../../src/crossbeam_epoch/atomic.rs.html#203">Source</a><a href="#method.deref" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../../../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref" class="fn">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a T</a></h4></section></summary><div class='docblock'>Dereferences the given pointer. <a href="../../../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a class="src rightside" href="../../../../src/crossbeam_epoch/atomic.rs.html#207">Source</a><a href="#method.deref_mut" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../../../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut" class="fn">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut T</a></h4></section></summary><div class='docblock'>Mutably dereferences the given pointer. <a href="../../../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="../../../../src/crossbeam_epoch/atomic.rs.html#211">Source</a><a href="#method.drop" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../../../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop" class="fn">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class='docblock'>Drops the object pointed to by the given pointer. <a href="../../../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#833-835">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.TryFrom.html" title="trait cs431_homework::test::loom::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../convert/trait.Into.html" title="trait cs431_homework::test::loom::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#837">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="../convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="../convert/enum.Infallible.html" title="enum cs431_homework::test::loom::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#840">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="../convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="../result/enum.Result.html" title="enum cs431_homework::test::loom::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../convert/trait.TryFrom.html" title="trait cs431_homework::test::loom::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="../convert/trait.TryFrom.html#associatedtype.Error" title="type cs431_homework::test::loom::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#817-819">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.TryInto.html" title="trait cs431_homework::test::loom::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../convert/trait.TryFrom.html" title="trait cs431_homework::test::loom::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#821">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="../convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="../convert/trait.TryFrom.html" title="trait cs431_homework::test::loom::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../convert/trait.TryFrom.html#associatedtype.Error" title="type cs431_homework::test::loom::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#824">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="../convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="../result/enum.Result.html" title="enum cs431_homework::test::loom::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../convert/trait.TryFrom.html" title="trait cs431_homework::test::loom::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../convert/trait.TryFrom.html#associatedtype.Error" title="type cs431_homework::test::loom::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a class="src rightside" href="../../../../src/ppv_lite86/types.rs.html#221-223">Source</a><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; <a class="trait" href="../../../../ppv_lite86/types/trait.VZip.html" title="trait ppv_lite86::types::VZip">VZip</a>&lt;V&gt; for T<div class="where">where
    V: <a class="trait" href="../../../../ppv_lite86/types/trait.MultiLane.html" title="trait ppv_lite86::types::MultiLane">MultiLane</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a class="src rightside" href="../../../../src/ppv_lite86/types.rs.html#226">Source</a><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a href="../../../../ppv_lite86/types/trait.VZip.html#tymethod.vzip" class="fn">vzip</a>(self) -&gt; V</h4></section></div></details></div></section></div></main></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Epoch-based memory reclamation."><title>crossbeam_epoch - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-069232aa.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="crossbeam_epoch" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (2fd855fbf 2025-08-07)" data-channel="nightly" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../crossbeam_epoch/index.html">crossbeam_<wbr>epoch</a><span class="version">0.9.18</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#pointers" title="Pointers">Pointers</a></li><li><a href="#pinning" title="Pinning">Pinning</a></li><li><a href="#garbage" title="Garbage">Garbage</a></li><li><a href="#apis" title="APIs">APIs</a></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>crossbeam_epoch</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/crossbeam_epoch/lib.rs.html#1-166">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Epoch-based memory reclamation.</p>
<p>An interesting problem concurrent collections deal with comes from the remove operation.
Suppose that a thread removes an element from a lock-free map, while another thread is reading
that same element at the same time. The first thread must wait until the second thread stops
reading the element. Only then it is safe to destruct it.</p>
<p>Programming languages that come with garbage collectors solve this problem trivially. The
garbage collector will destruct the removed element when no thread can hold a reference to it
anymore.</p>
<p>This crate implements a basic memory reclamation mechanism, which is based on epochs. When an
element gets removed from a concurrent collection, it is inserted into a pile of garbage and
marked with the current epoch. Every time a thread accesses a collection, it checks the current
epoch, attempts to increment it, and destructs some garbage that became so old that no thread
can be referencing it anymore.</p>
<p>That is the general mechanism behind epoch-based memory reclamation, but the details are a bit
more complicated. Anyhow, memory reclamation is designed to be fully automatic and something
users of concurrent collections don’t have to worry much about.</p>
<h2 id="pointers"><a class="doc-anchor" href="#pointers">§</a>Pointers</h2>
<p>Concurrent collections are built using atomic pointers. This module provides <a href="struct.Atomic.html" title="struct crossbeam_epoch::Atomic"><code>Atomic</code></a>, which
is just a shared atomic pointer to a heap-allocated object. Loading an <a href="struct.Atomic.html" title="struct crossbeam_epoch::Atomic"><code>Atomic</code></a> yields a
<a href="struct.Shared.html" title="struct crossbeam_epoch::Shared"><code>Shared</code></a>, which is an epoch-protected pointer through which the loaded object can be safely
read.</p>
<h2 id="pinning"><a class="doc-anchor" href="#pinning">§</a>Pinning</h2>
<p>Before an <a href="struct.Atomic.html" title="struct crossbeam_epoch::Atomic"><code>Atomic</code></a> can be loaded, a participant must be <a href="fn.pin.html" title="fn crossbeam_epoch::pin"><code>pin</code></a>ned. By pinning a participant
we declare that any object that gets removed from now on must not be destructed just
yet. Garbage collection of newly removed objects is suspended until the participant gets
unpinned.</p>
<h2 id="garbage"><a class="doc-anchor" href="#garbage">§</a>Garbage</h2>
<p>Objects that get removed from concurrent collections must be stashed away until all currently
pinned participants get unpinned. Such objects can be stored into a thread-local or global
storage, where they are kept until the right time for their destruction comes.</p>
<p>There is a global shared instance of garbage queue. You can <a href="struct.Guard.html#method.defer" title="method crossbeam_epoch::Guard::defer"><code>defer</code></a> the execution of an
arbitrary function until the global epoch is advanced enough. Most notably, concurrent data
structures may defer the deallocation of an object.</p>
<h2 id="apis"><a class="doc-anchor" href="#apis">§</a>APIs</h2>
<p>For majority of use cases, just use the default garbage collector by invoking <a href="fn.pin.html" title="fn crossbeam_epoch::pin"><code>pin</code></a>. If you
want to create your own garbage collector, use the <a href="struct.Collector.html" title="struct crossbeam_epoch::Collector"><code>Collector</code></a> API.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Atomic.html" title="struct crossbeam_epoch::Atomic">Atomic</a></dt><dd>An atomic pointer that can be safely shared between threads.</dd><dt><a class="struct" href="struct.Collector.html" title="struct crossbeam_epoch::Collector">Collector</a></dt><dd>An epoch-based garbage collector.</dd><dt><a class="struct" href="struct.CompareExchangeError.html" title="struct crossbeam_epoch::CompareExchangeError">Compare<wbr>Exchange<wbr>Error</a></dt><dd>The error returned on failed compare-and-swap operation.</dd><dt><a class="struct" href="struct.Guard.html" title="struct crossbeam_epoch::Guard">Guard</a></dt><dd>A guard that keeps the current thread pinned.</dd><dt><a class="struct" href="struct.LocalHandle.html" title="struct crossbeam_epoch::LocalHandle">Local<wbr>Handle</a></dt><dd>A handle to a garbage collector.</dd><dt><a class="struct" href="struct.Owned.html" title="struct crossbeam_epoch::Owned">Owned</a></dt><dd>An owned heap-allocated object.</dd><dt><a class="struct" href="struct.Shared.html" title="struct crossbeam_epoch::Shared">Shared</a></dt><dd>A pointer to an object protected by the epoch GC.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.CompareAndSetOrdering.html" title="trait crossbeam_epoch::CompareAndSetOrdering">Compare<wbr>AndSet<wbr>Ordering</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Memory orderings for compare-and-set operations.</dd><dt><a class="trait" href="trait.Pointable.html" title="trait crossbeam_epoch::Pointable">Pointable</a></dt><dd>Types that are pointed to by a single word.</dd><dt><a class="trait" href="trait.Pointer.html" title="trait crossbeam_epoch::Pointer">Pointer</a></dt><dd>A trait for either <code>Owned</code> or <code>Shared</code> pointers.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.default_collector.html" title="fn crossbeam_epoch::default_collector">default_<wbr>collector</a></dt><dd>Returns the default global collector.</dd><dt><a class="fn" href="fn.is_pinned.html" title="fn crossbeam_epoch::is_pinned">is_<wbr>pinned</a></dt><dd>Returns <code>true</code> if the current thread is pinned.</dd><dt><a class="fn" href="fn.pin.html" title="fn crossbeam_epoch::pin">pin</a></dt><dd>Pins the current thread.</dd><dt><a class="fn" href="fn.unprotected.html" title="fn crossbeam_epoch::unprotected">unprotected</a><sup title="unsafe function">⚠</sup></dt><dd>Returns a reference to a dummy guard that allows unprotected access to <a href="struct.Atomic.html" title="struct crossbeam_epoch::Atomic"><code>Atomic</code></a>s.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.CompareAndSetError.html" title="type crossbeam_epoch::CompareAndSetError">Compare<wbr>AndSet<wbr>Error</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>The error returned on failed compare-and-set operation.</dd></dl></section></div></main></body></html>